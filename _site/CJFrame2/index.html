<!doctype html> <html class="no-js" lang="en"> <head> <meta charset="utf-8" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <title>Android插件化开发，运行未安装apk中的Service</title> <link rel="stylesheet" href="/assets/css/styles_feeling_responsive.css"> <script src="/assets/js/modernizr.min.js"></script> <noscript> <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic%7cVolkhov' rel='stylesheet' type='text/css'> </noscript> <meta name="description" content="CJFrameForAndroid的具体用法"/> <link rel="author" href="https://plus.google.com/u/0/110645272912875945931"/> <link rel="icon" sizes="32x32" href="/assets/img/favicon-32x32.png"> <link rel="icon" sizes="192x192" href="/assets/img/touch-icon-192x192.png"> <link rel="apple-touch-icon-precomposed" sizes="180x180" href="/assets/img/apple-touch-icon-180x180-precomposed.png"> <link rel="apple-touch-icon-precomposed" sizes="152x152" href="/assets/img/apple-touch-icon-152x152-precomposed.png"> <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/img/apple-touch-icon-144x144-precomposed.png"> <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/assets/img/apple-touch-icon-120x120-precomposed.png"> <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/assets/img/apple-touch-icon-114x114-precomposed.png"> <link rel="apple-touch-icon-precomposed" sizes="76x76" href="/assets/img/apple-touch-icon-76x76-precomposed.png"> <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/assets/img/apple-touch-icon-72x72-precomposed.png"> <link rel="apple-touch-icon-precomposed" href="/assets/img/apple-touch-icon-precomposed.png"> <meta name="msapplication-TileImage" content="/assets/img/msapplication_tileimage.png"/> <meta name="msapplication-TileColor" content="#fabb00"> <!-- Facebook Optimization --> <meta property="og:locale" content="en_EN" /> <meta property="og:type" content="website" /> <meta property="og:title" content="Android插件化开发，运行未安装apk中的Service" /> <meta property="og:description" content="无论何时，请保持学者的谦逊与宽容。"/> <meta property="og:url" content="//CJFrame2/" /> <meta property="og:site_name" content="kymjs张涛" /> <!-- Search Engine Optimization --> <link type="text/plain" rel="author" href="//humans.txt" /> </head> <body id="top-of-page" class="page-fullwidth"> <div id="navigation" class="sticky"> <nav class="top-bar" data-topbar> <ul class="title-area"> <li class="name"> <h1 class="show-for-small-only"><a href="" class="icon-tree"> kymjs张涛</a></h1> </li> <!-- Remove the class "menu-icon" to get rid of menu icon. Take out "Menu" to just have icon alone --> <li class="toggle-topbar menu-icon"><a href="#"><span>Navigation</span></a></li> </ul> <section class="top-bar-section"> <ul class="right"> <li class="divider"></li> <li><a href="/donate">捐赠</a></li> <li class="divider"></li> <li><a href="/about">这是我</a></li> </ul> <ul class="left"> <li class="has-dropdown"> <a href="/code">代码与技术</a> <ul class="dropdown"> <li><a href="/code/android">Android</a></li> <li><a href="/code/ios">IOS</a></li> <li><a href="/code/algorithm">算法</a></li> </ul> </li> <li class="divider"></li> <li><a href="/product">产品体验分析</a></li> <li class="divider"></li> <li><a href="/read">阅读与感悟</a></li> <li class="divider"></li> <li><a href="/manager">开发团队管理</a></li> <li class="divider"></li> <li class="has-dropdown"> <a href="/osl">开源实验室</a> <ul class="dropdown"> <li><a href="/osl/framework">Android框架解读</a></li> <li><a href="/osl/ui">UI控件</a></li> <li><a href="/osl/app">开源APP</a></li> </ul> </li> <li class="divider"></li> </ul> </section> </nav> </div><!-- /#navigation --> <div class="row t30"> <div class="medium-12 columns"> <article> <header> <p class="subheadline">代码与技术</p> <h1>Android插件化开发，运行未安装apk中的Service</h1> </header> <p class="teaser"> CJFrameForAndroid的具体用法 </p> <p> &nbsp; &nbsp; &nbsp; &nbsp; 如果你还不知道什么叫插件化开发，那么你应该先读一读之前写的这篇博客：<a target="_blank" href="http://blog.kymjs.com/cjframeforandroid/2014/09/15/02/" rel="nofollow">Android插件化开发，初入殿堂</a><br /> </p> <p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上一篇博客主要从整体角度分析了一下Android插件化开发的几个难点与动态加载没有被安装的apk中的Activity和资源的方法。其实一般的插件开发主要也就是加载个Activity，读取一些资源图片之类的。但是总有遇到特殊情况的时候，比如加载Service。 </p> <p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要动态加载Service，有两种思路：一是通过NDK的形式，将Service通过C++运行起来（这种方法我没有尝试，只听群里的朋友说实现过）；另一种就是我使用的，具体思路和上一篇中提到加载Activity的方法一样，使用托管所的形式，由于上一篇博客没有讲清楚，这里就详细讲一下通过托管所实现加载插件中Service的方法。 </p> <p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下几点是每一个Android开发组肯定都知到的： 一个apk如果没有被安装的话是没有办法直接运行的。一个JAVA类的class文件是可以通过classload类加载器读取的。一个apk实际上就是一个压缩包，其中包含了一个.dex文件就是我们的代码文件。那么，接下来基本思路我们就可以明确了：apk没办法直接运行，apk中有代码文件，代码文件可以被classload读取。 </p> <p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Android中有两种classload，分别是DexClassLoader、PathClassLoader。后者只能加载/data/app目录下的apk也就是apk必须要安装才能被加载，这不是我们想要的，所以我们使用前者：DexClassLoader。 </p><pre class="brush:java;toolbar: true; auto-links: false;">public class CJClassLoader extends DexClassLoader {
//创建一个插件加载器集合，对固定的dex使用固定的加载器可以防止多个加载器同时加载一个dex造成的错误。
private static final HashMap&lt;String, CJClassLoader&gt; pluginLoader = new HashMap&lt;String, CJClassLoader&gt;();

protected CJClassLoader(String dexPath, String optimizedDirectory,
String libraryPath, ClassLoader parent) {
super(dexPath, optimizedDirectory, libraryPath, parent);
}

/**
* 返回dexPath对应的加载器
*/
public static CJClassLoader getClassLoader(String dexPath, Context cxt,
ClassLoader parent) {
CJClassLoader cjLoader = pluginLoader.get(dexPath);
if (cjLoader == null) {
// 获取到app的启动路径
final String dexOutputPath = cxt
.getDir(&quot;dex&quot;, Context.MODE_PRIVATE).getAbsolutePath();
cjLoader = new CJClassLoader(dexPath, dexOutputPath, null, parent);
pluginLoader.put(dexPath, cjLoader);
}
return cjLoader;
}
}</pre><p></p> <p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上只是一个开始，接着我们需要考虑一个问题，一个Service是有oncreate-&gt;onstart-&gt;ondestroy生命周期以及一些回调方法的，这些回调方法在我们正常使用的时候是由父类们（包括has...a...关系）或者说是SDK管理的，那么当我们通过类加载器加载的时候，它是没有能够管理的父类的，也就是说我们需要自己模拟SDK去管理插件Service的回调函数。那么这个去管理插件Service的类，就是之前提到的托管所。 </p> <p> 这里是我将Service中的回调方法抽出来写成的一个接口 </p><pre class="brush:java;toolbar: true; auto-links: false;">public interface I_CJService {
IBinder onBind(Intent intent);

void onCreate();

int onStartCommand(Intent intent, int flags, int startId);

void onDestroy();

void onConfigurationChanged(Configuration newConfig);

void onLowMemory();

void onTrimMemory(int level);

boolean onUnbind(Intent intent);

void onRebind(Intent intent);

void onTaskRemoved(Intent rootIntent);
}</pre><p></p> <p> . </p><pre class="brush:java;toolbar: true; auto-links: false;">//一个托管所类
class CJProxyService extends Service｛
//采用包含关系
protected I_CJService mPluginService; // 插件Service对象
｝</pre><p></p> <p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里采用包含关系而不是采用继承（或者说实现一个接口）的方式，是由于我们需要重写Service中的方法，而这些被重写的方法都需要用到接口对象相应的接口方法。<br /> </p><pre class="brush:java;toolbar: true; auto-links: false;">public class CJProxyService extends Service｛    
@Override
public void onConfigurationChanged(Configuration newConfig) {
mPluginService.onConfigurationChanged(newConfig);
super.onConfigurationChanged(newConfig);
}

@Override
public void onLowMemory() {
mPluginService.onLowMemory();
super.onLowMemory();
}

@Override
@SuppressLint(&quot;NewApi&quot;)
public void onTrimMemory(int level) {
mPluginService.onTrimMemory(level);
super.onTrimMemory(level);
}

@Override
public boolean onUnbind(Intent intent) {
mPluginService.onUnbind(intent);
return super.onUnbind(intent);
}

@Override
public void onRebind(Intent intent) {
mPluginService.onRebind(intent);
super.onRebind(intent);
}
｝</pre><p></p> <p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到这里大家应该也就明白了，托管所实际上就是一个普通的Service类，但是这个托管所是正常运行的，是由SDK管理回调函数的，我们通过这个Service的回调函数去调用插件Service中相应的回调方法，就间接的管理了插件Service的生命周期（此处可以类比Activity与Fragment的关系） </p> <p> 到这里为止，我们已经可以成功调起一个插件Service了，接下来的问题就是这个I_CJSrvice对象从哪里来？很简单，通过类加载器加载一个 </p><pre class="brush:java;toolbar: true; auto-links: false;">    private void init(Intent itFromApp) {

Object instance = null;
try {
Class&lt;?&gt; serviceClass;
if (CJConfig.DEF_STR.equals(mDexPath)) {
serviceClass = super.getClassLoader().loadClass(mClass);
} else {
serviceClass = this.getClassLoader().loadClass(mClass);
}
Constructor&lt;?&gt; serviceConstructor = serviceClass
.getConstructor(new Class[] {});
instance = serviceConstructor.newInstance(new Object[] {});
} catch (Exception e) {
}
setRemoteService(instance);
mPluginService.setProxy(this, mDexPath);
}

/**
* 保留一份插件Service对象
*/
protected void setRemoteService(Object service) {
if (service instanceof I_CJService) {
mPluginService = (I_CJService) service;
} else {
throw new ClassCastException(
&quot;plugin service must implements I_CJService&quot;);
}
}</pre><p></p> <p> 这样就可以拿到一个I_CJSrvice对象mPluginService了，如果到此为止，还是会有问题，因为此时mPluginService中例如onStart方法还对应的是那个插件中的onStart也就是父类的onStart（这里比较绕，我不知道该如何描述），而之前我们又说过，通过反射加载的类是没有父类的，那么如果此时强制调用那个反射对象的@Override方法是会报空指针的，因为找不到父类。那么解决的办法就是再去插件Service中重写每个@Override的方法。 </p><pre class="brush:java;toolbar: true; auto-links: false;">//.......篇幅有限，部分截取
public abstract class CJService extends Service implements I_CJService {
/**
* that指针指向的是当前插件的Context（由于是插件化开发，this指针绝对不能使用）
*/
protected Service that; // 替代this指针

@Override
public IBinder onBind(Intent intent) {
if (mFrom == CJConfig.FROM_PLUGIN) {
return null;
} else {
return that.onBind(intent);
}
}
}</pre><p></p> <p> 通过代可以看到：我们使用了一个that对象来替代原本的this对象，然后我们只需要通过在托管所中将这个that对象赋值为托管所的this对象，也就是插件中的所有that.xxx都相当于调用的是托管所的this.xxx，那么动态替换的目的就达到了，这样我们也就成功的加载了一个未被安装的插件apk中的Service。 </p> <p> &nbsp;&nbsp;&nbsp;&nbsp;有关本类中的代码，以及完整的Demo，你可以关注：<a target="_blank" href="https://github.com/kymjs/CJFrameForAndroid" rel="nofollow">Android插件式开发框架 CJFrameForAndroid</a><br /> </p> </article> </div><!-- /.medium-12.columns --> </div><!-- /.row --> <div id="up-to-top" class="row"> <div class="small-12 columns" style="text-align: right;"> <a class="iconfont" href="#top-of-page">&#xf108;</a> </div><!-- /.small-12.columns --> </div><!-- /.row --> <footer id="footer-content" class="bg-grau"> <div id="footer"> <div class="row"> <div class="medium-6 large-5 columns"> <h5 class="shadow-black">公众号：Android技术分享</h5> <p class="shadow-black"> <img src="/images/qrcode.jpg" alt="无论何时，请保持学者的谦逊与宽容。" width="120" height="120"/> </p> </div><!-- /.large-6.columns --> <div class="small-6 medium-3 large-3 large-offset-1 columns"> <h5 class="shadow-black">推荐站点</h5> <ul class="no-bullet shadow-black"> <li > <a href="" title=""></a> </li> <li class="services-contact" > <a href="/android_design" title="Android应用设计指南">Android应用设计指南</a> </li> <li class="services-contact" > <a href="/kjframe" title="KJFrame框架 API">KJFrameForAndroid API</a> </li> </ul> </div><!-- /.large-4.columns --> <div class="small-6 medium-3 large-3 columns"> <h5 class="shadow-black">推荐博客</h5> <ul class="no-bullet shadow-black"> <li > <a href="" title=""></a> </li> <li class="network-entypo" > <a href="http://www.xiequan.info/" target="_blank" title="谢权">Android达人-谢权</a> </li> <li class="services-newsletter" > <a href="http://www.vmatianyu.cn/" target="_blank" title="马天宇博客">bong智能：马天宇</a> </li> <li class="rss-link" > <a href="http://www.aplesson.com/" target="_blank" title="Android+PHP=APlesson">开源爱好者：谭东</a> </li> <li class="sitemap-link" > <a href="http://blog.csdn.net/bboyfeiyu" target="_blank" title="Mr.Simple">Mr.Simple博客</a> </li> </ul> </div><!-- /.large-3.columns --> </div><!-- /.row --> </div><!-- /#footer --> <div id="subfooter"> <nav class="row"> <section id="subfooter-left" class="b30 small-12 medium-6 columns"> <ul class="inline-list"> <li>站务联系 QQ:766136833 </li> </ul> </section> <section id="subfooter-right" class="small-12 medium-6 columns social-icons"> <ul class="inline-list"> <li><a href="http://twitter.com/kymjs123" target="_blank" class="icon-twitter" title="Twitter"></a></li> <li><a href="http://github.com/kymjs" target="_blank" class="icon-github" title="Code"></a></li> <li><a href="http://www.kymjs.com/" target="_blank" class="icon-xing" title="张涛"></a></li> </ul> </section> </nav> </div><!-- /#subfooter --> </footer> <script src="/assets/js/javascript.min.js"></script> </body> </html>
